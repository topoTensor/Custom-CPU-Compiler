#########################################################
#   Parser 2 file. Created on 26/6/25
#   Intent: Rewrite of the Pratt Parser. Explanation below.


# NOTE ON SINTAX:
# 1) All statements must be followed by a semicolon, including if, while, function and return statements.
#       i.e. function hello(a,b) {
#                   return a+b;
#            };  <- semicolon after the bracket
# 2) if and while statements can't have empty conditions

# *___________________________________________Explanation___________________________________________*
#
# Though I've tried not to make the recursive Pratt Parser, because I can't reason well with recursion,
#     but it's actually recursive in a sense. 
# How it's meant to be used: parser doesn't call itself,
#     but on the first step of parsing, it looks for a left-hand-side leaf, using '_make_leaf' function
#     and passing the existing iterator as an argument. 
# The catch is that the iterator will be advanced in the
#     '_make_leaf' function, thus skipping some parts, namely, numbers, parentheses and unary operations (for 6/26).
    
# What makes it recursive is that '_make_leaf' will call parse again but with different tokens (!), e.g.
#     the tokens inside the parentheses, and using the given result as the left side of the '_make_leaf'
#     (note: which can be both left side as the value of 'first' variable, and the right side as 
#     the value of 'right' variable in the loop over tokens.)
    
# To explain primary logic of the Pratt Parser is a bit difficult.
# First, we look for a node 'first'. 
# Then we iterate over tokens until it's either gone through all of them, 
#     as in the case of tokens inside the parentheses (which is called from _make_leaf), 
#     or until it encounters the EOF.
# We assume that if there's only a single number or expression (as in the case of Token "[1]" as an input)
#     we will encounter the EOF.
# In the case that there's another token, we assume there must be an operator, so we look for it.
# If there's no operator, we call an error.
# Then we look for the right hand side using '_make_leaf'.
# But, because the tree is not monotonic (!), we have to look for the last operation we've done (for the right side)
#     and check if our new operation is more urgent than the that one. 
# If it's the case, we do 'reverse' those two parts. e.g. (2+3)*4 -> 2+(3*4). 
# Note that we do all this because we kinda 'assume' the tree is left-leaning, i.e. 1+1+1 becomes (1+1)+1.
# If it's NOT the case, we leave it as it is. e.g. (2*3)+4 stays the same.

# About the '_make_leaf' function, it's more straightforward when the 'parse' logic works as intended.
# If it sees a left-parenth, it finds the right one (with checking if it's indeed the last one),
#     takes the tokens between them and passes to the 'parse' function.
# If inside the 'parse' it encounters another left-parenth, it does the same, until there are no parentheses.
# The precedence logic without parentheses has already been discussed.
    
# In the case when the 'first' element is not a number but a minus sign, it changes the value of the token
#     from '-' to '-u' to differentiate the precedence. Then when it's encountered for the precedence test, it does
#     (1+(-u 2)) * 3 -> 1+((-u 2) * 3), as it has the highest precedence.

# Otherwise '_make_leaf' just returns a number or identifier, which is put into the tree. 

# tl;dr
#
# 1)    The parse() function:
# 2)    Initializes the iterator.
# 3)    Calls _make_leaf() to extract the first "thing" (number, unary op, or parenthesis group).
# 4)    Builds an initial AST node from that.
# 5)    Then loops while there are more tokens:
#     6)    Checks if next token is EOF.
#     7)    Otherwise, assumes it's an operator.
#     8)    If not an operator, raises an error.
#     9)    Gets the right-hand side with _make_leaf() again.
#     10)   Then rebalances the AST depending on operator precedence.

# TODO : Some minor tweeks and enhancements. Better error logging. Do more tests. Prettier tree printing. See if you can solve the problem with writing semicolon after the cloing bracket, or at least add it to the documentation.

from iterator import Iterator
from tokens import Tokens
from abstract_syntax_tree import AST

class Parser2:
    def __init__(self, verbose=False):
        # TODO: honestly, verbose test printing must be enhanced.
        """ Verbose - if True prints additional information. For testing only """
        self.verbose = verbose

        self.precedence = {
            ';' : 0,
            ',' : 1,
            '=' : 5,
            '!=': 10, '==': 10, '<=': 10, '>=': 10, '<': 10, '>' : 10,
            '+' : 15, '-':  15,
            '*' : 20, '/' : 20,
            '-u': 1,
        }

    def parse(self, tokens, tokens_index=0):
        """ Entry point of the parser. tokens_index used only for debugging purposes. Tokens is a list of tokens generated by the Lexer class."""
        
        if len(tokens) == 0 or tokens[0].token_type == Tokens.EOF:
            return None

        iterator = Iterator(tokens, name = f'parser2-iterator-depth{tokens_index}')

        first = self._make_leaf(iterator, tokens_index+1)
        tree = AST(first, None, None)

        while iterator.cursor+1 < len(tokens):
            # got to the end of the tokens. Return the tree

            if iterator.peek().token_type == Tokens.EOF:
                break
            
            # stop parsing the statement. 'Glue' this tree to the next statement using (;) node. 
            # (statement1, ; , (statement2, ; , (statement3 ...))
            elif iterator.peek().value == ';':
                semicolon = iterator.peek()
                iterator.advance() # skip the semicolon

                # got to the end of the expression. Continue writing the tree from node (;). 
                # Notice the parse function on the RHS
                tree = AST(tree, semicolon, self.parse(tokens[iterator.cursor+1:],tokens_index+1))
                break
            

            # We assume a binary operator from here. Expressions of other forms must be handled by 'first' variable (look at the beginning of the function)

            # look at the operator
            iterator.advance()

            op = self._make_operator(iterator)
            if not iterator.can_peek():
                raise SyntaxError(f"no right side of operator {op}")
            
            # look at right side
            iterator.advance()

            right = self._make_leaf(iterator, tokens_index+1)

            if self.verbose: print('ops',tree.get_last_op(), op)
            if self.verbose: print('tree', tree)
            
            if tree.get_last_op() != None and self.precedence[tree.get_last_op().value] < self.precedence[op.value]:
                tree = AST(tree.lhs, tree.get_last_op(), AST(tree.rhs, op, right))
            else:
                tree = AST(tree, op, right)

        return tree

    def _make_leaf(self, iterator, tokens_index):
        """
            Returns a node for left or right hand-side.  
            If iterator points to a if/while keyword, returns (condition, keyword, statements) node.  
            If iterator points to a parenth, returns the parsed (using parse function recursively) expression inside the parentheses.  
            If iterator points to a minus sign, returns the unary 'mini-tree' (None, -u, expr).  

            Otherwise returns a number or identifier.
        """
        # keywords
        if iterator.word.token_type == Tokens.KEYWORD:
            # if or while
            if iterator.word.value == 'else':
                return self._build_else_if(iterator, tokens_index)
            elif iterator.word.value == 'if' or iterator.word.value == 'while':
                return self._build_if_while(iterator, tokens_index)
            elif iterator.word.value == 'function':
                return self._build_function_declaration(iterator, tokens_index)
            elif iterator.word.value == 'return':
                return self._build_return_statement(iterator, tokens_index)
            else:
                raise SyntaxError(f"PARSING ERROR: Unknown keyword {iterator.word}")

        # parentheses (expr)
        elif iterator.word.value == '(':
            i_start=iterator.cursor
            
            # find the position of the right parenth
            self._look_for_right_symbol(iterator, '(', ')')

            # parse the expression inside the parentheses and return as a new sub-tree
            result = self.parse(iterator.elements[i_start+1:iterator.cursor], tokens_index=tokens_index+1)
            return result
        
        # unary minus
        elif iterator.word.value == '-':
            if not iterator.can_peek():
                raise RuntimeError(f"No token after unary minus. Token {iterator.word}")
            else:
                # change the operation '-' into '-u' to differentiate the precedence in the 'parse' function.
                minus = iterator.word
                minus.value = '-u'
                iterator.advance()

                # parse the expression right after the minus.
                right = self._make_leaf(iterator, tokens_index + 1)

                # return (None, -u, expr)
                return AST(None, minus, right)

        # numbers and identifiers
        else:
            
            leaf = iterator.word

            # is it a function call?
            if iterator.can_peek() and iterator.peek().value == '(':
                i_start=iterator.cursor

                iterator.advance() # look at (
                self._look_for_right_symbol(iterator, '(', ')') 
                arguments_evaluation = self._evaluate_arguments(iterator.elements[i_start+1:iterator.cursor+1], tokens_index=tokens_index+1)
                return AST(None, leaf, arguments_evaluation)

            # if neither number nor identifier, raise a syntax err
            elif leaf.token_type != Tokens.NUMBER and leaf.token_type != Tokens.IDENTIFIER:
                raise SyntaxError(f"leaf is not of numeric or identifier type. Token {leaf}")
            
            return leaf
    
    def _make_operator(self, iterator):
        """
            If iterator points to an operator, either returns it or raises an error.
        """
        operator = iterator.word

        if operator.token_type != Tokens.OPERATOR and operator.token_type != Tokens.IDENTIFIER:
            raise SyntaxError(f"operator is not of numeric or identifier type. Token {operator}")
        
        return operator

    def _build_else_if(self, iterator, tokens_index):
        """
            Returns the tree for 'else if' and 'else' statements.   
            else if (expr) {statement;} and else {statement;}  

            Expected to run from the _make_leaf function.
        """
        if iterator.peek().value == 'if':
            # 'else if' branch
            keyword_token = iterator.word
            keyword_token.value = 'else_if'
            iterator.advance() # skip else

            return self._build_if_while(iterator, tokens_index)
        else:
            # just 'else'
            keyword_token = iterator.word

            if iterator.peek().value == '{':
                iterator.advance() # skip else, look at the bracket

                i_start=iterator.cursor

                # find the right bracket position
                self._look_for_right_symbol(iterator, '{', '}')

                # note you don't skip }, in order to read the semicolon

                # parse the statements inside the {} block
                result_bracket = self.parse(iterator.elements[i_start+1:iterator.cursor-1], tokens_index=tokens_index+1)

                # return the new node
                return AST(None, keyword_token, result_bracket)
            else:
                raise SyntaxError(f'Parser error: Else statement must be followed by a left bracket. Token {iterator.word}')


    def _build_if_while(self, iterator, tokens_index):
        """
            Returns the tree for 'if' and 'while' statements. Because they have similar syntax  
            if (expr) {statement;} v.s. while(expr) {statement;}  

            Expected to run from the _make_leaf function.
        """
        if iterator.word.value == 'if' or iterator.word.value == 'while':
            keyword_token = iterator.word

            # check if there's the left parenth
            if iterator.can_peek() and iterator.peek().value == '(':
                i_start=iterator.cursor

                iterator.advance() # skip if/while statement name

                # find the right parenth position
                self._look_for_right_symbol(iterator, '(', ')') 

                # parse the condition expression
                condition = self.parse(iterator.elements[i_start+1:iterator.cursor+1], tokens_index=tokens_index+1)

                # DEPRICATED, BECAUSE FUNCTIONS IN THEORY CAN RETURN TRUE STATEMENTS. FROM NOW, IF AND WHILE STATEMENTS WILL EXECUTE
                # ANYTIME WHEN IT CONDITION EVALUATES TO 1.
                # if condition.lhs.op.value not in ['<', '>', '==', '<=', '>=', '!=']: # check if it has condition expr inside
                #     raise Exception(f"If and while statements must have logical condition (<,>,==,<=,>=,!=) inside the parentheses. Token {iterator.word}")

                # check if there's the left bracket
                if iterator.can_peek() and iterator.peek().value == '{':
                    iterator.advance() # skip ). Rparenth of the condition

                    i_start=iterator.cursor

                    # find the right bracket position
                    self._look_for_right_symbol(iterator, '{', '}')

                    # note you don't skip }, in order to read the semicolon

                    # parse the statements inside the {} block
                    result_bracket = self.parse(iterator.elements[i_start+1:iterator.cursor-1], tokens_index=tokens_index+1)

                    # return the new node
                    return AST(condition, keyword_token, result_bracket)
                else:
                    # no left parenth
                    raise SyntaxError(f"PARSING SYNTAX ERROR : {keyword_token.value} statement condition must be followed by a left bracket. Token {iterator.word}")
            else:
                # no left bracket
                raise SyntaxError(f"PARSING SYNTAX ERROR : {keyword_token.value} keyword must be followed by a left parenth. Token {iterator.word}")
        else:
            # the keyword is neither 'if' nor 'while
            raise SyntaxError(f"PARSING SYNTAX ERROR : Expected 'if' or 'while' keyword. Unknown keyword {iterator.word} during _build_if_while function execution.")

    def _build_function_declaration(self, iterator, tokens_index):
        """
            Returns the tree for function declaration 'function func_name(arg1, arg2...) { statements }'  

            Expected to run from the _make_leaf function.
        """
        if iterator.word.value == 'function':
            keyword_token = iterator.word

            func_name = iterator.advance()

            # check if there's the left parenth
            if iterator.can_peek() and iterator.peek().value == '(':
                i_start=iterator.cursor

                iterator.advance() # skip function name
                iterator.advance() # skip left parenth

                # parse the arguments sequence expression till the right parenth
                arguments = self._tokens_of_comma_sequence(iterator, tokens_index=tokens_index+1)

                # check if there's the left bracket
                if iterator.can_peek() and iterator.peek().value == '{':
                    iterator.advance() # skip ). Rparenth of the arguments sequence

                    i_start=iterator.cursor

                    # find the right bracket position
                    self._look_for_right_symbol(iterator, '{', '}')

                    # note you don't skip }, in order to read the semicolon

                    # parse the statements inside the {} block
                    result_bracket = self.parse(iterator.elements[i_start+1:iterator.cursor-1], tokens_index=tokens_index+1)

                    # return the new node
                    return AST(arguments, func_name, result_bracket)
                else:
                    # no left parenth
                    raise SyntaxError(f"PARSING SYNTAX ERROR : {func_name} function name must be followed by a left bracket. Token {iterator.word}")
            else:
                # no left bracket
                raise SyntaxError(f"PARSING SYNTAX ERROR : {keyword_token.value} keyword must be followed by a left parenth. Token {iterator.word}")
        else:
            # the keyword is neither 'if' nor 'while
            raise SyntaxError(f"PARSING SYNTAX ERROR : Expected 'function' keyword for function declaration. Unknown keyword {iterator.word} during _build_if_while function execution.")


    def _build_return_statement(self, iterator, tokens_index=0):
        return_token = iterator.word
        iterator.advance() # skip return word 

        i_start = iterator.cursor
        
        while iterator.can_peek() and iterator.peek().value != ';':
            iterator.advance()

        # now it looks at the word before comma. So that after parsing it will until the comma

        parsed = self.parse(iterator.elements[i_start: iterator.cursor+1], tokens_index+1)

        return AST(parsed, return_token, None)

    def _evaluate_arguments(self, tokens, tokens_index=0):
        """
            turns expressions of the form (expr1, expr2,...) into tree (expr1 , (expr2, (expr3, ...)))
        """
        leaf= self.parse(tokens, tokens_index+1)

        return leaf

    def _tokens_of_comma_sequence(self, iterator:Iterator, tokens_index=0):

        """ Collects arguments from an input of the form 'arg1, arg2, arg3).  
            Used in function declaration in _make_leaf function.
        """

        args = []
        if not iterator.can_peek():
            # if no right parenth
            raise SyntaxError(f"function arguments are not complete. No tokens to traverse. Token {iterator.word}")
        else:
            # if no arguments
            if iterator.word.value == ')':
                return args

        # store arguments and ignore commas. Do until it sees a right parenth
        while iterator.can_peek():
            args.append(iterator.pre_advance())
            if iterator.word.value == ')':
                break
            elif iterator.word.value != ',':
                raise SyntaxError(f"Expected comma in functions arguments {args}")
            else:
                iterator.advance()

        # note you don't skip the )

        return args


    def _look_for_right_symbol(self, iterator:Iterator, left, right):
        """
            ! Iterator must point to the left symbol at the beginning.
            ! In the end it will point to the last right symbol.
            e.g. it will start at '(' in '(1+(2+3))' and point at the last ')' in the expression.
            Traverses the iterator until it finds the right pair for the symbol left (usually parentheses and brackets).
        """
        

        seen_parenth=0
        while True:

            if iterator.word.value == left:
                seen_parenth+=1
            elif iterator.word.value == right:
                seen_parenth-=1

            if iterator.word.value == right and seen_parenth == 0:
                break

            if not iterator.can_peek():
                raise IndexError(f"LOOKAHEAD PARSING ERROR: Iterator {repr(iterator.name)} couldn't find the right pair {right} for the left symbol {left}. Last token {iterator.word}.")
            
            iterator.advance()