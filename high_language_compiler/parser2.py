#########################################################
#   Parser 2 file. Created on 26/6/25
#   Intent: Rewrite of the Pratt Parser. Explanation below.

# *___________________________________________Explanation___________________________________________*
#
# Though I've tried not to make the recursive Pratt Parser, because I can't reason well with recursion,
#     but it's actually recursive in a sense. 
# How it's meant to be used: parser doesn't call itself,
#     but on the first step of parsing, it looks for a left-hand-side leaf, using '_make_leaf' function
#     and passing the existing iterator as an argument. 
# The catch is that the iterator will be advanced in the
#     '_make_leaf' function, thus skipping some parts, namely, numbers, parentheses and unary operations (for 6/26).
    
# What makes it recursive is that '_make_leaf' will call parse again but with different tokens (!), e.g.
#     the tokens inside the parentheses, and using the given result as the left side of the '_make_leaf'
#     (note: which can be both left side as the value of 'first' variable, and the right side as 
#     the value of 'right' variable in the loop over tokens.)
    
# To explain primary logic of the Pratt Parser is a bit difficult.
# First, we look for a node 'first'. 
# Then we iterate over tokens until it's either gone through all of them, 
#     as in the case of tokens inside the parentheses (which is called from _make_leaf), 
#     or until it encounters the EOF.
# We assume that if there's only a single number or expression (as in the case of Token "[1]" as an input)
#     we will encounter the EOF.
# In the case that there's another token, we assume there must be an operator, so we look for it.
# If there's no operator, we call an error.
# Then we look for the right hand side using '_make_leaf'.
# But, because the tree is not monotonic (!), we have to look for the last operation we've done (for the right side)
#     and check if our new operation is more urgent than the that one. 
# If it's the case, we do 'reverse' those two parts. e.g. (2+3)*4 -> 2+(3*4). 
# Note that we do all this because we kinda 'assume' the tree is left-leaning, i.e. 1+1+1 becomes (1+1)+1.
# If it's NOT the case, we leave it as it is. e.g. (2*3)+4 stays the same.

# About the '_make_leaf' function, it's more straightforward when the 'parse' logic works as intended.
# If it sees a left-parenth, it finds the right one (with checking if it's indeed the last one),
#     takes the tokens between them and passes to the 'parse' function.
# If inside the 'parse' it encounters another left-parenth, it does the same, until there are no parentheses.
# The precedence logic without parentheses has already been discussed.
    
# In the case when the 'first' element is not a number but a minus sign, it changes the value of the token
#     from '-' to '-u' to differentiate the precedence. Then when it's encountered for the precedence test, it does
#     (1+(-u 2)) * 3 -> 1+((-u 2) * 3), as it has the highest precedence.

# Otherwise '_make_leaf' just returns a number or identifier, which is put into the tree. 

# tl;dr
#
# 1)    The parse() function:
# 2)    Initializes the iterator.
# 3)    Calls _make_leaf() to extract the first "thing" (number, unary op, or parenthesis group).
# 4)    Builds an initial AST node from that.
# 5)    Then loops while there are more tokens:
#     6)    Checks if next token is EOF.
#     7)    Otherwise, assumes it's an operator.
#     8)    If not an operator, raises an error.
#     9)    Gets the right-hand side with _make_leaf() again.
#     10)   Then rebalances the AST depending on operator precedence.

from iterator import Iterator
from tokens import Tokens
from abstract_syntax_tree import AST

class Parser2:
    def __init__(self, verbose=False):
        # TODO: honestly, verbose test printing must be enhanced.
        """ Verbose - if True prints additional information. For testing only """
        self.verbose = verbose

        self.precedence = {
            '=' : 5,
            '!=': 10, '==': 10, '<=': 10, '>=': 10, '<': 10, '>' : 10,
            '+' : 15, '-':  15,
            '*' : 20, '/' : 20,
            '-u': 1,
        }

    def parse(self, tokens, tokens_index=0):
        """ Entry point of the parser. tokens_index used only for debugging purposes. Tokens is a list of tokens generated by the Lexer class."""
        
        if len(tokens) == 0 or tokens[0].token_type == Tokens.EOF:
            return None

        iterator = Iterator(tokens, name = f'parser2-iterator-depth{tokens_index}')

        first = self._make_leaf(iterator, tokens_index)
        tree = AST(first, None, None)

        while iterator.cursor+1 < len(tokens):
            # got to the end of the tokens. Return the tree
            if iterator.peek().token_type == Tokens.EOF:
                break
            
            # stop parsing the statement. 'Glue' this tree to the next statement using (;) node. 
            # (statement1, ; , (statement2, ; , (statement3 ...))
            elif iterator.peek().value == ';':
                semicolon = iterator.peek()
                iterator.advance() # skip the semicolon

                # got to the end of the expression. Continue writing the tree from node (;). 
                # Notice the parse function on the RHS
                tree = AST(tree, semicolon, self.parse(tokens[iterator.cursor+1:],0))
                break
            

            # We assume a binary operator from here. Expressions of other forms must be handled by 'first' variable (look at the beginning of the function)

            # look at the operator
            iterator.advance()

            op = self._make_operator(iterator)
            if not iterator.can_peek():
                raise SyntaxError(f"no right side of operator {op}")
            
            # look at right side
            iterator.advance()

            right = self._make_leaf(iterator, tokens_index)

            if self.verbose: print('ops',tree.get_last_op(), op)
            if self.verbose: print('tree', tree)
            
            if tree.get_last_op() != None and self.precedence[tree.get_last_op().value] < self.precedence[op.value]:
                tree = AST(tree.lhs, tree.get_last_op(), AST(tree.rhs, op, right))
            else:
                tree = AST(tree, op, right)

        return tree

    def _make_leaf(self, iterator, tokens_index):
        """
            Returns a node for left or right hand-side.  
            If iterator points to a if/while keyword, returns (condition, keyword, statements) node.  
            If iterator points to a parenth, returns the parsed (using parse function recursively) expression inside the parentheses.  
            If iterator points to a minus sign, returns the unary 'mini-tree' (None, -u, expr).  

            Otherwise returns a number or identifier.
        """
        
        # keywords
        if iterator.word.token_type == Tokens.KEYWORD:
            # if or while
            return self._build_if_while(iterator, tokens_index)

        # parentheses (expr)
        elif iterator.word.value == '(':
            i_start=iterator.cursor
            
            # find the position of the right parenth
            self._look_for_right_symbol(iterator, '(', ')')

            # parse the expression inside the parentheses and return as a new sub-tree
            result = self.parse(iterator.elements[i_start+1:iterator.cursor], tokens_index=tokens_index+1)
            return result
        
        # unary minus
        elif iterator.word.value == '-':
            if not iterator.can_peek():
                raise RuntimeError(f"No token after unary minus. Token {iterator.word}")
            else:
                # change the operation '-' into '-u' to differentiate the precedence in the 'parse' function.
                minus = iterator.word
                minus.value = '-u'
                iterator.advance()

                # parse the expression right after the minus.
                right = self._make_leaf(iterator, tokens_index + 1)

                # return (None, -u, expr)
                return AST(None, minus, right)

        # numbers and identifiers
        else:
            leaf = iterator.word
            # if neither number nor identifier, raise a syntax err
            if leaf.token_type != Tokens.NUMBER and leaf.token_type != Tokens.IDENTIFIER:
                raise SyntaxError(f"leaf is not of numeric or identifier type. Token {leaf}")
            
            return leaf
    
    def _make_operator(self, iterator):
        """
            If iterator points to an operator, either returns it or raises an error.
        """
        operator = iterator.word

        if operator.token_type != Tokens.OPERATOR and operator.token_type != Tokens.IDENTIFIER:
            raise SyntaxError(f"operator is not of numeric or identifier type. Token {operator}")
        
        return operator


    def _build_if_while(self, iterator, tokens_index):
        """
            Returns the tree for 'if' and 'while' statements. Because they have similar syntax  
            if (expr) {statement;} v.s. while(expr) {statement;}  

            Expected to run from the _make_leaf function.
        """
        if iterator.word.value == 'if' or iterator.word.value == 'while':
            keyword_token = iterator.word

            # check if there's the left parenth
            if iterator.can_peek() and iterator.peek().value == '(':
                i_start=iterator.cursor

                iterator.advance() # skip if/while statement name

                # find the right parenth position
                self._look_for_right_symbol(iterator, '(', ')') 

                # parse the condition expression
                condition = self.parse(iterator.elements[i_start+1:iterator.cursor+1], tokens_index=tokens_index+1)

                # check if there's the left bracket
                if iterator.can_peek() and iterator.peek().value == '{':
                    iterator.advance() # skip ). Rparenth of the condition

                    i_start=iterator.cursor

                    # find the right bracket position
                    self._look_for_right_symbol(iterator, '{', '}')

                    iterator.advance() # skip }

                    # parse the statements inside the {} block
                    result_bracket = self.parse(iterator.elements[i_start+1:iterator.cursor-1], tokens_index=tokens_index+1)

                    # return the new node
                    return AST(condition, keyword_token, result_bracket)
                else:
                    # no left parenth
                    raise SyntaxError(f"PARSING SYNTAX ERROR : {keyword_token.value} statement condition must be followed by a left bracket. Token {iterator.word}")
            else:
                # no left bracket
                raise SyntaxError(f"PARSING SYNTAX ERROR : {keyword_token.value} keyword must be followed by a left parenth. Token {iterator.word}")
        else:
            # the keyword is neither 'if' nor 'while
            raise SyntaxError(f"PARSING SYNTAX ERROR : Unknown keyword {iterator.word} during _build_if_while function execution.")



    def _look_for_right_symbol(self, iterator:Iterator, left, right):
        """
            ! Iterator must point to the left symbol at the beginning.
            ! In the end it will point to the last right symbol.
            e.g. it will start at '(' in '(1+(2+3))' and point at the last ')' in the expression.
            Traverses the iterator until it finds the right pair for the symbol left (usually parentheses and brackets).
        """
        

        seen_parenth=0
        while True:

            if iterator.word.value == left:
                seen_parenth+=1
            elif iterator.word.value == right:
                seen_parenth-=1

            if iterator.word.value == right and seen_parenth == 0:
                break

            if not iterator.can_peek():
                raise IndexError(f"LOOKAHEAD PARSING ERROR: Iterator {repr(iterator.name)} couldn't find the right pair {right} for the left symbol {left}. Last token {iterator.word}.")
            
            iterator.advance()