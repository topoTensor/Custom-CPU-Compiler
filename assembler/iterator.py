#   Iterator file. Created on 22/6/25
#   Intent: Generalizes the lexer and parser classes. Can be used separately (as in Parser class to parse sub expressions).
#           I chose the name of the variable "word" to make accidentally miss-typing the letter 's' in "elements" less probable.

class Iterator:
    """
        * elements - the "thing" that must be iterated uppone.  
        \t In case of lexer it's the raw input string.
        \t In case of Parser it's the tokens list, generated by the lexer.

        * name - the namme of the iterator (e.g. 'Lexer', 'Parser' etc.). It's displayed during error messages.

        * word - the element currently pointed by the cursor.

        * functions interface - can_peek, peek, advance.
        \t can_peek - returns whether the cursor can advance one step.
        \t peek     - returns the next element, but doesn't advance. Raises an error if looks out-of-bounds.
        \t advance  - advances the cursor and returns the next element. Raises an error if advances out-of-bounds.
        \t pre_advance - returns the current element pointed by the cursor and then advances the cursor by a single step. Raises an error if advances out-of-bounds.
    """
    def __init__(self, elements, name='Iterator'):
        self.elements = elements
        self.cursor = 0
        if len(self.elements) == 0:
            raise RuntimeError(f"Iterator error: Iterator {name} has just received an empty input list")
        else:
            self.word = self.elements[0]

        self.name = name # will be displayed during error messages

    # advances the cursor by a single step. Raises an error if out-of-bounds.
    def advance(self):
        if self.can_peek():
            self.cursor += 1
            self.word = self.elements[self.cursor]
            return self.word
        else:
            raise SyntaxError(f"{self.name} tried to advance out-of-bounds element at position {self.cursor}")

    # returns the CURRENT element pointed by the cursor and then advances the cursor by a single step
    def pre_advance(self):
        old_word = self.word
        self.advance()
        return old_word

    # returns the next character, but doesn't advance the cursor. Raises an error if tries to look out-of-bounds
    def peek(self):
        if self.can_peek():
            return self.elements[self.cursor+1]
        else:
            raise SyntaxError(f"{self.name} tried to peek out-of-bounds character at position {self.cursor}")

    # returns whether the next step is out-of-bounds of elements
    def can_peek(self):
        return self.cursor+1 < len(self.elements)